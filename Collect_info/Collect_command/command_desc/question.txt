Solution du matching:
On s'en tient a la tokenization du commande input et des pattern mais on va modifier la technique
de comparaison

La technique de comparaison avant:
soit l'input: "git commit -m "init""
soit le db : 
  "git": [
            {
              "description": "Create an empty Git repository",
              "cmd": "git init"
            },
            {
              "description": "Commit changes to version history",
              "cmd": "git commit {{[-m|--message]}} {{message_text}}"
            }
  ]
On tokenize input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
on fait la comparaison avec les tokens du premier cmd de "git":
=>  "cmd": "git init" : [pe_0:"git", pe_1:"git init"]

COMPARAISON pour el_0:
on compare el_0 avec tous les pe_i du premier cmd, tout de suite el_0 correspond a pe_0,
le programme arrete la comparaison pour el_0 et lui donne la 
desc_0: "Create an empty Git repository", alors que c'est la description pour git init

Puis, il passe a la comparaison de el_1, ni pe_0 ni pe_1 ne correspond, et on descend au prochain
cmd:
=> "cmd": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m",...]
Ici, el_1 corrspond a pe_2, et la aussi on associe a desc_1 : "Commit changes to version history",

C'est ce que je veux corriger pour la techine de comparaison:

NOUVEAU TECHNIQUE DE COMPARAISON:
On garde la tokenization:
On tokenize input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message", "{{message_text}}"]

Pour trouver une bonne correspondance de commande:
On garde dabord tous les el_i et les pe_i de type=cmd, cmdopt, bref de type commande:

=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message"]

et on compare el_i a seulement pe_i pour cmd_i, c-a-d:
Par exemple, 

on va comparer 'input a cmd_1 et voir si ca correspond:
=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]

el_0: git - pe_0: git => same
el_1: git commit - pe_1: git init => diff

=> tout de suite pas de correspondance, alors on passe au prochain cmd_i:

On va maintenant comparer input a cmd_2 et voir si ca correspond:
=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message"]

el_0: git - pe_0: git => same
el_1: git commit - pe_1: git commit => same
el_2: git commit -m - pe_2: git commit -m => same
=> Tout corrsepond on peut confier la description desc_1, 

Remarque: meme si il y en a encore el_3, jusqu'a el_p, mais el_0 jusqu'a el_3 correspond 
a tous les tokens de type commande du pattern, on ajoute une description

Pour les types non commande de l'input , on le definit juste selon son type dans la description
. Tu comprend ?





On va plutot faire ceci pour le matching:
On garde la tokenization de l'input et des patterns.

Soit l'input Enter command: ls -l /home/user -a
- On tokenize dabord l'input:
Element analysis:
  el_0: ls
  el_1: ls -l
  el_2: /home/user
  el_3: ls -a

1. On premier temps , on tente de trouver une full description,
On garde que les el_i de type commande, et les pe_i de type commande.
et on passe a cette comparaison:
On garde la tokenization:
On tokenize input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message", "{{message_text}}"]

Pour trouver une bonne correspondance de commande:
On garde dabord tous les el_i et les pe_i de type=cmd, cmdopt, bref de type commande:

=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message"]

et on compare el_i a seulement pe_i pour cmd_i, c-a-d:
Par exemple, 

on va comparer 'input a cmd_1 et voir si ca correspond:
=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=>  "cmd_1": "git init" : [pe_0:"git", pe_1:"git init"]

el_0: git - pe_0: git => same
el_1: git commit - pe_1: git init => diff

=> tout de suite pas de correspondance, alors on passe au prochain cmd_i:

On va maintenant comparer input a cmd_2 et voir si ca correspond:
=> input : [el_0:"git", el_1:"git commit", el_3:"git commit -m"]
=> "cmd_2": "git commit {{[-m|--message]}} {{message_text}}" : ["git", "git commit", "git commit -m"/"git commit --message"]

el_0: git - pe_0: git => same
el_1: git commit - pe_1: git commit => same
el_2: git commit -m - pe_2: git commit -m => same
=> Tout corrsepond on peut confier la description desc_1, 

Remarque:
Si el_0 jusqu'a el_N correspond a pe_0 jusqu'a pe_N, alors on a le full description,
=> Full descrit
sinon on n'en a pas et passe a la description sequentielle.